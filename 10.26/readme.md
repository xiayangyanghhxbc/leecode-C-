## 2520-统计能整除数字的位数-简单

给你一个整数 num ，返回 num 中能整除 num 的数位的数目。

如果满足 nums % val == 0 ，则认为整数 val 可以整除 nums 。

 

示例 1：

输入：num = 7
输出：1

解释：7 被自己整除，因此答案是 1 。


示例 2：

输入：num = 121
输出：2

解释：121 可以被 1 整除，但无法被 2 整除。由于 1 出现两次，所以返回 2 。


示例 3：

输入：num = 1248
输出：4

解释：1248 可以被它每一位上的数字整除，因此答案是 4 。

## 70-爬楼梯-简单
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？


示例 1：

输入：n = 2
输出：2

解释：有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶

2. 2 阶


示例 2：

输入：n = 3
输出：3

解释：有三种方法可以爬到楼顶。

1. 1 阶 + 1 阶 + 1 阶

2. 1 阶 + 2 阶

3. 2 阶 + 1 阶

学习两种解题思路：

### 爬楼梯问题 - 动态规划

#### 问题描述

有一座楼梯，它有 `n` 级台阶。你站在第 `0` 级台阶，每次可以选择爬一级或两级台阶。求爬到第 `n` 级台阶的不同方案数。

#### 思路和算法

我们可以使用动态规划来解决这个问题。定义一个函数 `f(x)` 表示爬到第 `x` 级台阶的方案数。考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，因此我们可以列出如下递推关系式：

>f(x) = f(x-1) + f(x-2)


这意味着爬到第 `x` 级台阶的方案数是爬到第 `x-1` 级台阶的方案数和爬到第 `x-2` 级台阶的方案数的和。因为每次只能爬 1 级或 2 级，所以 `f(x)` 只能从 `f(x-1)` 和 `f(x-2)` 转移过来。我们需要对这两项的贡献求和，以计算出方案总数。

#### 边界条件

我们是从第 `0` 级开始爬的，所以从第 `0` 级爬到第 `0` 级只有一种方案，即 `f(0) = 1`。从第 `0` 级到第 `1` 级也只有一种方案，即爬一级， `f(1) = 1`。这两个作为边界条件可以继续向后推导出第 `n` 级的正确结果。

#### 代码示例

```C++
class Solution {
public:
    int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for (int i = 1; i <= n; ++i) {
            p = q; 
            q = r; 
            r = p + q;
        }
        return r;
    }
};
```

以上是动态规划的转移方程和边界条件，可以使用滚动数组思想将空间复杂度优化为 O(1)。这个算法的时间复杂度和空间复杂度都是 O(n)。

### 复杂度分析

- 时间复杂度：循环执行 `n` 次，每次花费常数的时间代价，故渐进时间复杂度为 `O(n)`。

- 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 `O(1)`。

### 方法二：矩阵快速幂

#### 思路

以上的方法适用于 `n` 比较小的情况，在 `n` 变大之后， `O(n)` 的时间复杂度会让这个算法看起来有些捉襟见肘。我们可以用「矩阵快速幂」的方法来优化这个过程。

首先我们可以构建这样一个递推关系：

[ 
1
1

1
0
​	
 ][ 
f(n)
f(n−1)
​	
 ]=[ 
f(n)+f(n−1)
f(n)
​	
 ]=[ 
f(n+1)
f(n)
​	
 ]


因此：


>[f(n+1) f(n)] = [1 1]

>[1 0] ^ n

>[f(1) f(0)]



令：

M = [1 1]
    [1 0]

因此我们只要能快速计算矩阵 `M` 的 `n` 次幂，就可以得到 `f(n)` 的值。如果直接求取 `M^n`，时间复杂度是 `O(n)` 的，我们可以定义矩阵乘法，然后用快速幂算法来加速这里 `M^n` 的求取。

如何想到使用矩阵快速幂？

- 如果一个问题可以转化为求解一个矩阵的 `n` 次方的形式，那么可以用快速幂来加速计算。
- 如果一个递归式形如 `f(n) = ∑(i=1 to m) a_i f(n-i)`，即齐次线性递推式，我们就可以把数列的递推关系转化为矩阵的递推关系，即构造出一个矩阵的 `n` 次方乘以一个列向量得到一个列向量，这个列向量中包含我们要求的 `f(n)`。一般情况下，形如 `f(n) = ∑(i=1 to m) a_i f(n-i)` 可以构造出这样的 `m x m` 的矩阵：

>[a1 a2 a3 ... am]
>
>[1 0 0 ... 0 ]
>
>[0 1 0 ... 0 ]
>
>[0 0 1 ... 0 ]
>
>...
>
>[0 0 0 ... 1 ]


那么遇到非齐次线性递推我们是不是就束手无策了呢？其实未必。有些时候我们可以把非齐次线性递推转化为其次线性递推，比如这样一个递推：

>f(x) = (2x - 6) c + f(x-1) + f(x-2) + f(x-3)


我们可以做这样的变换：

>f(x) + xc = [f(x-1) + (x-1)c] + [f(x-2) + (x-2)c] + [f(x-3) + (x-3)c]


令 `g(x) = f(x) + xc`，那么我们又得到了一个齐次线性递：

>g(x) = g(x-1) + g(x-2) + g(x-3)



于是就可以使用矩阵快速幂求解了。当然并不是所有非齐次线性都可以化成齐次线性，我们还是要具体问题具体分析。

## 1561-你可以获得的最大硬币数目-中等


### 分硬币博弈问题

你和你的朋友们面临一个分硬币的博弈问题，规则如下：

- 有3n堆硬币，每堆硬币数量不同。
- 每一轮中，你将会选出任意3堆硬币，不一定连续。
- Alice将会取走硬币数量最多的那一堆。
- 你将会取走硬币数量第二多的那一堆。
- Bob将会取走最后一堆。
- 重复这个过程，直到没有更多硬币。

你的任务是找到可以获得的最大硬币数目。给定一个整数数组 `piles`，其中 `piles[i]` 是第 `i` 堆中硬币的数目。

#### 示例

**输入**:
```python
piles = [2,4,1,2,7,8]

输出

9

```

#### 解释:

选出 (2, 7, 8)，Alice 取走8枚硬币的那堆，你取走7枚硬币的那堆，Bob 取走最后一堆。

选出 (1, 2, 4)，Alice 取走4枚硬币的那堆，你取走2枚硬币的那堆，Bob 取走最后一堆。


你可以获得的最大硬币数目为7 + 2 = 9。

#### 提示
3 <= piles.length <= 10^5

piles.length % 3 == 0

1 <= piles[i] <= 10^4

### 贪心

一共有3n 堆硬币，每个人都会取走n 堆硬币，因此在取走的硬币堆的数量确定的情况下，为了获得最大硬币数目，在每次取走一堆硬币时，应取走数量最多的一堆硬币。

显然，Alice 一定会取走 3n 堆硬币中数量最多的一堆硬币，在 Alice 取走数量最多的一堆硬币之后，我们可以取走数量第二多的一堆硬币。当 n=1 时，一共有3 堆硬币，每个人都只能取走1 堆硬币，因此我们可以获得的最大硬币数目即为数量第二多的一堆硬币的数目。

当n≥2 时，如何获得最大硬币数目？和n=1 的情况相似，第一轮时，Alice 取走数量最多的，我们取走数量第二多的，但不同的是我们不让Bob 取走数量第三多的，我们让 Bob 取走数量最少的。第二轮时，应该让 ALic 取走数量第三多的一堆硬币，我们就取走数量第四多的一堆硬币，以此类推。试想如果我们在第一轮让 Bb 拿走了第三多的，按照这个策路我们只能在第二轮拿到数量第五多的，以此类推，这个策略不如前面的策略好。

基于上述分析，可以看到，每一轮中，ALce 取数量最多的一堆硬币，我们取数量第二多的一堆硬币，可以让我们获得最大硬币数目。由于每一轮中要进出3堆硬币，其中的最后一堆由Bob 取走，为了不让 Bob 影响我们获得的最大硬币数目，只要让 Bob 每次取的硬币是所有堆中数量最少的即可。

为了方便地知道每一堆硬币的数量之间的关系，首先对数组进行排序。排序后的数组的前n 个元素是最小的元素，留给 Bob，其余的元素则分别属于我们和 ALice。

每一轮，我们选出3 堆硬币，包括数量最多的 2 堆硬币和数量最少的 1 堆硬币，我们总能获得这 3 堆硬币中的数量第二多的硬币。

计算可以获得的最大硬币数目时，每次遍历 2个元素，其中较小的元素即为这一轮取走的硬币数量按照从大到小的顺序遍历数组中的元素.

```C++
class Solution {
public:
    int maxCoins(vector<int>& piles) {
        sort(piles.begin(), piles.end());
        int length = piles.size();
        int rounds = length / 3;
        int coins = 0;
        int index = length - 2;
        for (int i = 0; i < rounds; i++) {
            coins += piles[index];
            index -= 2;
        }
        return coins;
    }
};

```
